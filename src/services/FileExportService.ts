import { markdownRenderer } from './MarkdownRenderer';

export interface ExportOptions {
	filename?: string;
	includeTimestamp?: boolean;
	includeMetadata?: boolean;
	format?: 'markdown' | 'html' | 'txt';
}

export interface ExportMetadata {
	exportDate: string;
	wordCount: number;
	characterCount: number;
	estimatedReadingTime: number;
	source?: string;
}

export class FileExportService {
	private static instance: FileExportService;

	private constructor() {}

	static getInstance(): FileExportService {
		if (!FileExportService.instance) {
			FileExportService.instance = new FileExportService();
		}
		return FileExportService.instance;
	}

	async exportToFile(
		content: string,
		options: ExportOptions = {}
	): Promise<void> {
		const {
			filename = this.generateFilename(
				options.format || 'markdown',
				options.includeTimestamp
			),
			includeMetadata = false,
			format = 'markdown',
		} = options;

		let exportContent = content;
		let mimeType = 'text/plain';
		let fileExtension = '.txt';

		// Prepare content based on format
		switch (format) {
			case 'markdown':
				if (includeMetadata) {
					exportContent = this.addMetadataToMarkdown(content);
				}
				mimeType = 'text/markdown';
				fileExtension = '.md';
				break;

			case 'html':
				exportContent = this.convertToHtml(content, includeMetadata);
				mimeType = 'text/html';
				fileExtension = '.html';
				break;

			case 'txt':
				exportContent = this.convertToPlainText(content, includeMetadata);
				mimeType = 'text/plain';
				fileExtension = '.txt';
				break;
		}

		// Create and download the file
		const blob = new Blob([exportContent], { type: mimeType });
		const url = URL.createObjectURL(blob);
		const a = document.createElement('a');
		a.href = url;
		a.download = filename.endsWith(fileExtension)
			? filename
			: filename + fileExtension;
		document.body.appendChild(a);
		a.click();
		document.body.removeChild(a);
		URL.revokeObjectURL(url);
	}

	async copyToClipboard(content: string): Promise<boolean> {
		try {
			await navigator.clipboard.writeText(content);
			return true;
		} catch (error) {
			console.error('Failed to copy to clipboard:', error);
			return false;
		}
	}

	async copyHtmlToClipboard(content: string): Promise<boolean> {
		try {
			const htmlContent = this.convertToHtml(content, false);

			// Try to copy as both HTML and plain text
			const clipboardItem = new ClipboardItem({
				'text/html': new Blob([htmlContent], { type: 'text/html' }),
				'text/plain': new Blob([content], { type: 'text/plain' }),
			});

			await navigator.clipboard.write([clipboardItem]);
			return true;
		} catch (error) {
			// Fallback to plain text
			console.warn(
				'Failed to copy HTML to clipboard, falling back to plain text:',
				error
			);
			return this.copyToClipboard(content);
		}
	}

	private generateFilename(
		format: string,
		includeTimestamp: boolean = true
	): string {
		const base = 'pr-review';
		const timestamp = includeTimestamp ? `-${Date.now()}` : '';
		const extension =
			format === 'markdown' ? '.md' : format === 'html' ? '.html' : '.txt';
		return `${base}${timestamp}${extension}`;
	}

	private addMetadataToMarkdown(content: string): string {
		const metadata = this.generateMetadata(content);
		const metadataBlock = `---
Export Date: ${metadata.exportDate}
Word Count: ${metadata.wordCount}
Character Count: ${metadata.characterCount}
Estimated Reading Time: ${metadata.estimatedReadingTime} min
Generated by: PReviewer
---

`;
		return metadataBlock + content;
	}

	private convertToHtml(content: string, includeMetadata: boolean): string {
		const rendered = markdownRenderer.render(content);
		const metadata = includeMetadata ? this.generateMetadata(content) : null;

		const htmlTemplate = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PR Review Export</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
        }
        .metadata {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            font-size: 0.9em;
        }
        .metadata h3 {
            margin-top: 0;
        }
        pre {
            background: #f8f8f8;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }
        code {
            background: #f0f0f0;
            padding: 2px 4px;
            border-radius: 3px;
        }
        blockquote {
            border-left: 4px solid #ddd;
            margin: 0;
            padding-left: 20px;
            color: #666;
        }
    </style>
</head>
<body>
    ${
			metadata
				? `
    <div class="metadata">
        <h3>Export Information</h3>
        <p><strong>Export Date:</strong> ${metadata.exportDate}</p>
        <p><strong>Word Count:</strong> ${metadata.wordCount}</p>
        <p><strong>Character Count:</strong> ${metadata.characterCount}</p>
        <p><strong>Estimated Reading Time:</strong> ${metadata.estimatedReadingTime} min</p>
        <p><strong>Generated by:</strong> PReviewer</p>
    </div>
    `
				: ''
		}
    <div class="content">
        ${rendered.isUsingLibrary ? rendered.html : `<pre>${rendered.html}</pre>`}
    </div>
</body>
</html>`;

		return htmlTemplate;
	}

	private convertToPlainText(
		content: string,
		includeMetadata: boolean
	): string {
		const plainText = markdownRenderer.extractPlainText(content);

		if (!includeMetadata) {
			return plainText;
		}

		const metadata = this.generateMetadata(content);
		const metadataText = `Export Information:
Export Date: ${metadata.exportDate}
Word Count: ${metadata.wordCount}
Character Count: ${metadata.characterCount}
Estimated Reading Time: ${metadata.estimatedReadingTime} min
Generated by: PReviewer

---

`;

		return metadataText + plainText;
	}

	private generateMetadata(content: string): ExportMetadata {
		return {
			exportDate: new Date().toLocaleString(),
			wordCount: markdownRenderer.getWordCount(content),
			characterCount: markdownRenderer.getCharacterCount(content),
			estimatedReadingTime: markdownRenderer.getEstimatedReadingTime(content),
		};
	}

	getExportPreview(
		content: string,
		format: 'markdown' | 'html' | 'txt'
	): string {
		switch (format) {
			case 'html':
				return this.convertToHtml(content, true);
			case 'txt':
				return this.convertToPlainText(content, true);
			case 'markdown':
			default:
				return this.addMetadataToMarkdown(content);
		}
	}

	validateContent(content: string): { isValid: boolean; warnings: string[] } {
		const warnings: string[] = [];

		if (!content || content.trim().length === 0) {
			return { isValid: false, warnings: ['Content is empty'] };
		}

		if (content.length > 1000000) {
			// 1MB limit
			warnings.push('Content is very large and may cause performance issues');
		}

		const wordCount = markdownRenderer.getWordCount(content);
		if (wordCount < 10) {
			warnings.push('Content appears to be very short');
		}

		return { isValid: true, warnings };
	}
}

export const fileExportService = FileExportService.getInstance();
